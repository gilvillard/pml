/**
 * \file nmod_mat_poly.h
 * \brief Main header for univariate polynomial with matrix coefficients modulo word-size prime
 * \version 0.0
 * \date 2023-02-13
 *
 * This is the main header for functions for univariate polynomials with
 * coefficients that are matrices over a finite field Z/pZ for "small" p
 * (word-size, so that we use a representation with flint's ``nmod``). Only 
 * operations for which this `nmod_mat_poly` format is best suited are
 * provided. For other operations it is suggested to rely the conversions to and
 * from `nmod_poly_mat` format and use the relevant functions for that format.
 *
 * \todo benchmark performance
 * \todo test for memory leaks
 * \todo Note: all parameters are supposed init
 *
 */

#ifdef NMOD_MAT_POLY_INLINES_C
#define NMOD_MAT_POLY_INLINE FLINT_DLL
#else
#define NMOD_MAT_POLY_INLINE static __inline__
#endif

#ifndef NMOD_MAT_POLY_H
#define NMOD_MAT_POLY_H

#include <flint/perm.h>
#include <flint/nmod_mat.h>

#ifdef __cplusplus
extern "C" {
#endif

/*------------------------------------------------------------*/
/* struct, typedefs                                           */
/*------------------------------------------------------------*/

/** Struct for matrix polynomials.
 *
 * Storage is a dynamic array of matrices `nmod_mat`. The maximum number of
 * coefficients is `alloc` and the actual number of coefficients (which is the
 * degree plus 1) is `length`. The number of rows and columns are `r` and `c`.
 * The modulus is stored as an `nmod_t`. In the provided functions, e.g. for
 * modifying a coefficient, it is not checked that the dimensions of the
 * modified coefficient are indeed `r x c`.
 */
typedef struct
{
    nmod_mat_struct * coeffs; /**< array of coefficients */
    slong alloc;              /**< allocated length */
    slong length;             /**< actual length */
    slong r;                  /**< number of rows */
    slong c;                  /**< number of columns */
    nmod_t mod;               /**< modulus */
} nmod_mat_poly_struct;

typedef nmod_mat_poly_struct nmod_mat_poly_t[1];

/*------------------------------------------------------------*/
/* memory management                                          */
/*------------------------------------------------------------*/

/** @name Memory management for matrix polynomials
 */
//@{

/** Initialises `matp`. It will have dimensions `r x c` and coefficients modulo
 * `n`. */
FLINT_DLL void nmod_mat_poly_init(nmod_mat_poly_t matp,
                                  slong r, slong c,
                                  mp_limb_t n);

/** Initialises `matp`. It will have dimensions `r x c` and coefficients modulo
 * `n`. The caller supplies a precomputed inverse limb generated by
 * `n_preinvert_limb()`. */
FLINT_DLL void nmod_mat_poly_init_preinv(nmod_mat_poly_t matp,
                                         slong r, slong c,
                                         mp_limb_t n, mp_limb_t ninv);

/** Initialises `matp`. It will have dimensions `r x c` and coefficients modulo
 * `n`. Up to alloc coefficients may be stored in `matp`. Implementation note:
 * the `alloc` matrix coefficients are not initialized. */
FLINT_DLL void nmod_mat_poly_init2(nmod_mat_poly_t matp,
                                   slong r, slong c,
                                   mp_limb_t n,
                                   slong alloc);

/** Initialises `matp`. It will have dimensions `r x c` and coefficients
 * modulo~`n`. The caller supplies a precomputed inverse limb generated by
 * n_preinvert_limb(). Up to alloc coefficients may be stored in `matp`.
 * Implementation note: the `alloc` matrix coefficients are not initialized. */
FLINT_DLL void nmod_mat_poly_init2_preinv(nmod_mat_poly_t matp, 
                                          slong r, slong c,
                                          mp_limb_t n, mp_limb_t ninv,
                                          slong alloc);

/** Reallocates `matp` to the given length `alloc`. If the current `length` is
 * more than `alloc`, the polynomial is truncated and normalised. If `alloc` is
 * zero, the polynomial is cleared. */
FLINT_DLL void nmod_mat_poly_realloc(nmod_mat_poly_t matp, slong alloc);

/** Clears `matp` and releases any memory it used. The matrix polynomial cannot be
used again until it is initialised. */
FLINT_DLL void nmod_mat_poly_clear(nmod_mat_poly_t matp);

/** Ensures `matp` has space for at least `alloc` coefficients. This function
 * only ever grows the allocated space, so no data loss can occur. */
FLINT_DLL void nmod_mat_poly_fit_length(nmod_mat_poly_t matp, slong alloc);

/** Initialises `matp` using an already initialised modulus `mod`. */
NMOD_MAT_POLY_INLINE void
nmod_mat_poly_init_mod(nmod_mat_poly_t matp,
                       slong r, slong c,
                       const nmod_t mod)
{
    matp->coeffs = NULL;
    matp->alloc = 0;
    matp->length = 0;
    matp->r = r;
    matp->c = c;
    matp->mod = mod;
}

NMOD_MAT_POLY_INLINE
void nmod_mat_poly_set_mod(nmod_mat_poly_t matp, const nmod_t mod)
{
    matp->mod = mod;
}

//NMOD_MAT_POLY_INLINE
//void _nmod_mat_poly_set_length(nmod_mat_poly_t matp, slong len)
//{
//    matp->length = len;
//}

/** Normalises a matrix polynomial `matp` so that the top coefficient, if there
 * is one at all, is not zero. */
NMOD_MAT_POLY_INLINE
void _nmod_mat_poly_normalise(nmod_mat_poly_t matp)
{
    while (matp->length && nmod_mat_is_zero(matp->coeffs + matp->length - 1))
    {
        nmod_mat_clear(matp->coeffs + matp->length - 1);
        matp->length--;
    }
}

//@} // doxygen group:  Memory management for matrix polynomials




/** @name Truncate, shift, reverse.
 * \todo TODO
 */
//@{

/** Truncates `matp` to the given `order` and normalises it. If `order` is
 * greater than the current length of `matp`, then nothing happens. */
NMOD_MAT_POLY_INLINE void
nmod_mat_poly_truncate(nmod_mat_poly_t matp, slong order)
{
    if (matp->length > order)
    {
        for (slong i = order; i < matp->length; i++)
            nmod_mat_clear(matp->coeffs + i);
        matp->length = order;
        _nmod_mat_poly_normalise(matp);
    }  
}




























































/** void nmod_mat_poly_naive_mul_coef(nmod_mat_t res,
 *				       const nmod_mat_poly_t A,
 *				       const nmod_mat_poly_t B, slong k);
 *
 * A = sum^{deg_A}_{i=0} a_i x^i and B = sum^{deg_B}_{i=0} b_i x^i
 * Compute the coefficient k of the product AB
 * C = AB = sum^{deg_A + deg_B}_{i=0} c_i x^i
 * res = c_k = sum^{k}_{i=0} a_i b_{k-i}
 *
 */
void nmod_mat_poly_naive_mul_coef(nmod_mat_t res,
                                  const nmod_mat_poly_t A,
                                  const nmod_mat_poly_t B,
                                  slong k);

void nmod_mat_poly_print(const nmod_mat_poly_t A);


#ifdef __cplusplus
}
#endif

#endif /* NMOD_MAT_POLY_H */

/* -*- mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
// vim:sts=4:sw=4:ts=4:et:sr:cino=>s,f0,{0,g0,(0,\:0,t0,+0,=s
